<!DOCTYPE html>
<html>
    <head>
        <title>Purdue Formula SAE : fsaeSTAR dossier</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">Purdue Formula SAE</a></span>
                            </li>
                                                    <li>
                                <span><a href="Purdue-Formula-SAE-Home_127569448.html">Purdue Formula SAE Home</a></span>
                            </li>
                                                    <li>
                                <span><a href="Aerodynamics_129007673.html">Aerodynamics</a></span>
                            </li>
                                                    <li>
                                <span><a href="259297341.html">Design | AER</a></span>
                            </li>
                                                    <li>
                                <span><a href="259297342.html">Design Resources | AER</a></span>
                            </li>
                                                    <li>
                                <span><a href="228301297.html">Computational Fluid Dynamics (CFD)</a></span>
                            </li>
                                                    <li>
                                <span><a href="fsaeSTAR-Manual_259297491.html">fsaeSTAR Manual</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            Purdue Formula SAE : fsaeSTAR dossier
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
    
        
    
        
        
            Created by <span class='author'> Unknown User (agarw162)</span>, last modified by <span class='editor'> Zhang, Chenkai</span> on Aug 15, 2023
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <p><span>Written in either fsaeSTAR V3.0 era. Updated for fsaeSTAR V6.4.</span></p><p><span>Here we’re going to talk about some of the thinking behind the macros. I don’t really want to explain every single line in the code…because that’s not super useful. I will ramble about the thinking behind each macro, and if there’s anything interesting I learned along the way, and things I’d do differently if I were to re-write it for the third time. </span><span> </span></p><p><strong><u><span class="TextRun SCXW261903199 BCX0"><span class="NormalTextRun SCXW261903199 BCX0">MacroController.java</span></span></u></strong></p><p>Start with MacroController.java because that’s where every macro flow starts from. The idea behind MacroController is to logically organize different macros based on high-level operations. All the pre-processing macros are grouped together, all the process macros are grouped together, and all the postprocess macros are grouped together.  </p><p>Why do we have so many macros? It keeps files smaller, and it’s easier to test individual macros when they’re doing something small and specific, rather than doing a lot of different things one after the other.  </p><p>Why am I calling MeshRepair three times in the mesh pipeline? We want to make sure we don’t create invalid cells as a result of the MeshRepair itself. Sometimes removing bad cells ends up giving you a discontiguous mesh. Fixing this requires another call to MeshRepair. I have no idea how to get a true/false boolean out of MeshRepair for whether or not the mesh is invalid, otherwise I’d have a loop that keeps running meshRepair until the code returns a false for “are there any invalid cells”.  </p><p>What’s the deal with SoftRun.java and MeshRepair.java? Sometimes STAR doesn’t realize there’s an invalid cell until<em> after</em> it tries running an iteration. Sometimes STAR crashes completely if it tries to solve a mesh with an invalid cell. softRun.java makes sure STAR makes that realization that there is an invalid cell, and then when it crashes, only softRun.java crashes, rather than the whole processing pipeline. The weird SoftRun -&gt; MeshRepair -&gt; SoftRun -&gt; MeshRepair pipeline minimizes the occurrence of this happening.  </p><p>Should you save the sim at the end of every macro? -&gt; No. Saving the sim is a ton of overhead and can easily add 20-30 minutes of extra run time if you’re saving the sim at the end of every macro. Ideally, save the sim after every “major” operation.  </p><p>A neat thing to do is get STAR to generate a report for the simulation at the end of every MacroController run. This generates an .html file with every single property and setting of the simulation files. A neat little way to check the resulting simulation file without having to open the sim file.   </p><p><u><strong><span class="TextRun SCXW75616383 BCX0"><span class="NormalTextRun SCXW75616383 BCX0">SimComponents.java</span></span><span class="EOP SCXW75616383 BCX0"> </span></strong></u></p><p>SimComponents essentially does the heavy lifting of taking (mostly) everything in STAR and turns it into an easily accessible Java object. In fsaeSTAR V1, every macro had to do this independently, which was really stupid since you’d have the same chunk of “iterate through all part surfaces, find RW surfaces” code repeated in multiple different macros. SimComponents eliminates this by handling all the “book-keeping” once.</p><p>While the intent behind SimComponents was noble, the structure isn’t very consistent. Some of this book-keeping occurs in SimComponent’s constructor. Some occurs in methods within SimComponents that are called by SimComponents's constructor, and some of this happens in SimComponents methods that must be called by your macro, and are not automatically taken care of during construction. Strings are also a bit of a cluster. Some strings are treated as static constants, defined at the top of SimComponents. Some strings are defined as simple variables inside simComponents, and some strings are still magic. This inconsistency with strings isn’t really an issue as far as the code’s functionality is concerned, but can become a pain in the ass if you ever change the name of a specific node in your simulation file, and now suddenly STAR can’t find that node because its name changed, and you have no idea where that string is defined/used in fsaeSTAR. I like the idea of eliminating magic strings in random locations, and making sure everything is defined explicitly as a static final string on the top of SimComponents.  </p><p>All in all, SimComponents isn’t doing anything fancy. It assigns nodes in your simulation tree to logical members in the class, and filters through things like surfaces to make sure you’re not re-filtering every time you want a specific surface.  </p><p>SimComponents runs every single time a new macro is called. This is some overhead (takes a few hundred ms for simComponents to run), but it’s a very small-brain and easy way to make sure your SimComponents are as up-to-date as possible. The performance you’d gain by only generating SimComponents once probably only adds up to a couple minutes by the end of a full preprocess-process-postprocess pipeline.  </p><p>SimComponents also handles a lot of helper functions. Things like parsing a sysEnv variable… </p><p><u><strong><span class="TextRun SCXW19140929 BCX0"><span class="NormalTextRun SCXW19140929 BCX0">DomainSet.java</span></span></strong><span class="EOP SCXW19140929 BCX0"> </span></u></p><p>Domain set gives you can easy way to switch between full car, half car, and wind tunnel sims, as they all require changes to the domain block.</p><p><u><strong><span class="TextRun SCXW133925687 BCX0"><span class="NormalTextRun SCXW133925687 BCX0">RideHeight.java</span></span><span class="EOP SCXW133925687 BCX0"> </span></strong></u></p><p>It’s self-explanatory. It pulls sysEnvs for “frh” and “rrh”. Instead of moving the car, the domain is moved. There are upsides and downsides to this. The upside are 1. the sim ends up breaking less since you are not messing with car geometry, and 2. instead of entering a delta value, you enter the absolute values (although there are ways to do this as well if you are moving the car), the downside is that the code is rather confusing and is not really consistent with the rest of the things we do. So if you switch to moving the car, I won't blame you. The center of rotation is calculated according to the difference between front and rear ride height. The domain block is rotated about that center by degrees calculated with simple trig. The wheels are not moved. Note this ride height change is not 100% representative of ride height changes in real life since suspensions components don't get moved.</p><p><u><strong>RollSet.java</strong></u></p><p>Sets roll by rotating the car about the car center line. Tried to do domain rotation instead, but it has compatibility issues with RideHeight.java, and I was too lazy to do the math and make architectural changes to make them capable. Again, this is not 100% representative of the real life since there is no suspension geometry changes.</p><p><strong><u><span class="TextRun SCXW112326624 BCX0"><span class="NormalTextRun SCXW112326624 BCX0">Steering.java</span></span></u><span class="EOP SCXW112326624 BCX0"> </span> </strong></p><p>Rotates the wheels about their yaw axes to account for the car’s steering input. Again, this gets wonky since this doesn’t change your suspension geometry. This does require your front wheel coordinate system’s origin to be consistent with your front left tyre, and your front wheel steering coordinate system’s origin to be consistent with your front right tyre.  </p><p><u><strong><span class="TextRun SCXW43536614 BCX0"><span class="NormalTextRun SCXW43536614 BCX0">SurfaceWrap.java and AutoMesh.java</span></span><span class="TextRun SCXW43536614 BCX0"><span class="NormalTextRun SCXW43536614 BCX0"> and Subtract.java</span></span><span class="EOP SCXW43536614 BCX0"> GroundRefinement.java</span></strong></u></p><p>There’s quite literally nothing interesting going on here. We’re just setting up the meshers and executing them. The interesting stuff is in STAR in this case (mesh settings and whatnot). fsaeSTAR will never directly alter mesh settings (at least for now…) </p><p>subtract.java is <em>slightly</em> interesting. It checks (well, SimComponents checks…) to see if the simulation is a cornering sim (“domain_c” exists). If it does, the target part will be the toroidal domain, not the straight domain.  </p><p><u><strong><span class="TextRun SCXW126637799 BCX0"><span class="NormalTextRun SCXW126637799 BCX0">Regions.java</span></span><span class="EOP SCXW126637799 BCX0"> </span></strong></u></p><p>Things start getting a little more interesting with Regions.java. This is one of those macros where theoretically you could do the whole thing using just STAR’s macro recorder, and don’t <em>have</em> to write a full custom macro for it. That is, in fact, what we did for this in 2017 and 2018. Even the first whack at Regions.java was pretty damn close to a “recorded” macro in fsaeSTAR V1. Since then, regions has grown into…something a little more monstrous. From 2019 to 2022 (fsaeSTAR V6.2), regions were deleted and recreated each time. The main issue with that approach was you could end up 10000 boundaries thanks to powertrain, and things get very hard to find. </p><p>From 2022 onwards, a set of regions and boundaries exists permanently. Instead of creating boundaries from geometries, geometries are set to boundaries. For example, AER_FW is the front wing boundary, FS_GROUND is the ground boundary, and NON_AERO is the boundary for all of chassis, suspension, powertrain, electronics, and bodyworks. Nice and simple and easy to find. </p><p>Regions.java also handles everything that has to do with the radiators, fans, and fan shrouds. There is a separate page detailing how it's done, there is a lot of details that can get lost in such a massive page.</p><p><u><strong><span class="TextRun SCXW187458347 BCX0"><span class="NormalTextRun SCXW187458347 BCX0">MeshRepair.java</span></span><span class="EOP SCXW187458347 BCX0"> </span></strong></u></p><p><span>MeshRepair.java handles automatic mesh repairing. It's one of the simplest macros since it's almost entirely recorded.</span></p><p><span>Before we had mesh repair, we would either move the car by a hundredth of an inch and hope for the best (this worked 60% of the time), or we would manually monitor the simulation until just before the sim crashes.</span></p><p>MeshRepair repairs the mesh in two ways:</p><ol><li><span>MeshRepair</span><span> runs before every sim run to delete poor quality cells</span><span> (using STAR defaults)</span><span>, cells with negative volumes, and splits the domain to remove any </span><span>discontigous</span><span> regions.</span></li><li>MeshRepair also has the option to delete cells that are marked as bad with a custom field function. Global maximum velocity monitor is used as of now. But the way it operates has gone through considerable changes. In the past, MeshRepair kicks in when maximum velocity exceeds 1000 m/s and cells above 500 m/s are removed. You might think 1000 m/s and 500 m/s sound terribly fast, and you would right, no flow around the car should achieve Mach 3+ when the car is driving at 40 mph. But that's just because we had a bad mesh and extremely localized speeds of over 200 m/s were common occurrence and were considered acceptable. Another reason is that the way the sim exploded in the past. It was usually sudden jumps from a normal speed to 1000+ m/s in a few short iterations. So this makes sense. Since the mesh rebuild of fsaeSTAR V6.4, the quality of mesh improved significantly and we are no longer accepting speeds of 200 m/s. Now, MeshRepair kciks in when aximum velocity exceeds 3x freestream and cells with speeds over 3x freestream are removed. This is because the way the sims explode changed. Now, it's always a gradual increase in speed of a single cell over a few hundred iterations. Once the speed exceeds 3x freestream, the cell is removed, and everything else should be good.</li></ol><p><span style="color: rgb(0,0,0);"><strong><span class="TextRun SCXW219226731 BCX0"><span class="NormalTextRun SCXW219226731 BCX0"><u>Save.java</u></span></span><u><span class="EOP SCXW219226731 BCX0"> </span></u></strong></span></p><p><span>Saves simulation files</span><span>. </span><span>¯\_(</span><span>ツ</span><span>)_/¯</span><span> </span></p><p><span style="color: rgb(0,0,0);"><u><strong><span class="TextRun SCXW101788428 BCX0"><span class="NormalTextRun SCXW101788428 BCX0">YawSet.java</span></span><span class="EOP SCXW101788428 BCX0"> </span></strong></u></span></p><p><span>This sets up boundary conditions for yaw. In the past, we did yaw by rotating the vehicle relative to the domain. That approach</span><span> of rotating the vehicle</span><span> isn’t ideal, since </span><span>you have to re</span><span>-</span><span>mesh the vehicle every </span><span>time you want to change yaw</span><span>….which</span><span> doesn’t make any sense. </span><span> </span></p><p><span>For straight-line, Y</span><span>awSet</span><span> (well, regions.java….YawSet </span><span>just calls the functions in regions) sets left and right freestream boundaries as velocity inlets.</span></p><p><span style="color: rgb(0,0,0);"><u><strong><span class="TextRun SCXW124464371 BCX0"><span class="NormalTextRun SCXW124464371 BCX0">GenReports.java</span></span><span class="TextRun SCXW124464371 BCX0"><span class="NormalTextRun SCXW124464371 BCX0"> and ExportReports.java</span></span></strong></u></span></p><p><span>Nothing interesting going on here. </span><span>There’s</span><span> some sampling shenanigans going on, which is mostly a remnant from DES runs Raunaq was working on. When DES becomes a </span><span>focus again, it’s probably a good idea to redo how </span><span>fsaeSTAR</span><span> handles DES entirely, rather than trying to hack something using the existing logic that exists. </span><span>When dealing with tables (how we generate reports.csv), for some odd reason STAR requires you to sample a point part in the domain. E</span><span>xportReports</span><span> handles this as well as spitting out all the reports to text files, and the reports table to a .csv file. </span><span> </span></p><p><u><span style="color: rgb(0,0,0);"><strong><span class="TextRun SCXW62914395 BCX0"><span class="NormalTextRun SCXW62914395 BCX0">SoftRun.java and Run.java</span></span></strong><span class="EOP SCXW62914395 BCX0"> </span></span></u></p><p><span>Sometimes STAR doesn’t realize there are negative volume or otherwise invalid cells, or </span><span>discontiguous</span><span> regions in the simulation until after the first iteration. If this happens, STAR and the macro crash. softRun.java only runs a </span><span>single iteration, so if STAR crashes a macro, it’ll crash softRun.java, rather than Run.java.</span></p><p><span>Run.java executes the simulation in 3 mode depending on the where on the solution process the sim if. For the first 200 (or however many you are using), it execute the &quot;first order upwind initialization mode&quot; with first order upwind scheme for convection and high relaxation factors to &quot;initialize&quot; the flow field quickly. The majority of the sim is spent in the &quot;second order upwind mode&quot; with second order upwind scheme and moderate relaxation factors to transition the solution from a first order solution to a moderately converged second order solution, which is more accurate. The final stage of execution is the &quot;final convergence mode&quot;, which triggers at a convergence score of 200 (or whatever number you are using), with second order upwind scheme and low relaxation factors to reduce oscillations in the results and achieve good convergence. All three modes work together to not only increase solution accuracy, but also drastically increases solution speed. We saw up to 35% solution speed increase, but a more representative number would be 10-20% increase in solution speeds. The relaxation factors can definitely be fine tuned. I did not pursue it too far since we are probably only shaving off 100 iterations max, but it requires running maybe 20 simulations to get there. Not only that, the exact optimal relaxation factors depends on the the geometry. So to really get a good idea if a set of relaxation factors are better, you need to run it through a mini design cycle or a set of predefined geometries. </span><span> </span></p><p><span style="color: rgb(0,0,0);"><u><strong>ConvergenceChecker.java</strong></u></span></p><p><span>This macro is case of &quot;if it's stupid and works, it's not stupid&quot;. There is no mathematical background behind the convergence checker, but it works too well for anyone to bother to fix it.</span></p><p><span>ConvergenceChecker takes moving average of the value of interest (usually CL) and looks at the difference between max and min, and standard deviation of the moving average values. If the product of the difference between max and min, standard deviation, and 2500 is less than than 10, the sim is converged.</span></p><p><span>If you want to do something about it, a P-norm would be a good place to start.</span></p><p><span style="color: rgb(0,0,0);"><u><strong><span class="TextRun SCXW145388715 BCX0"><span class="NormalTextRun SCXW145388715 BCX0">PostProc.java</span></span></strong></u></span></p><p><span>Post proc is a bit of a mess. It’s gotten better, but it’s still a mess. </span><span>Partly because there’s no clean way to do it from my experience. P</span><span>ostProc</span><span> </span><span>iterates through every plot and generates a .txt file and a .</span><span>png</span><span> file for each plot. It does not do anything to plot scaling, so however the plot is configured in the sim file, is what you get in the </span><span>png</span><span> file. The text file output is independent of the plot view </span><span>settings, and</span><span> will always be the same. </span><span> </span></p><p>2D scene export goes through all 2D displayers, views, and positions, enforces the naming convection, and dumps everything as png into a folder. This process takes a long time and there really isn't a way to speed it up. Using GPU for rendering could help, but so far no one figured out how to do GPU rendering on the back end. With this, things that take longer to render will export slower. For example, velocity glyphs that we used to export is the worst offender. 2D scene export requires a plane section derived part to work, it doesn't make one for you.</p><p>3D scene export is much simpler. It export the 3D displayers as a .scn file, which can be opened using STAR-CCM+ viewer. This method of export is not only more flexible by allowing you to view 3D scenes in 3D, but it's also much faster than exporting pngs.</p><p>Post processing as of now still takes longer than I would like. The real solution lies in getting rid of pngs altogether and just export the cell data, and use third party post processor to visualize the results. However, the issues is that the files can get huge, and people need to have the 3D post processor and a good enough computer to run it. If you are taking a look at this though, ParaView is a good option as a third party post processor since it's free and open source.</p>
                    </div>

                                        
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Mar 04, 2024 13:25</p>
                    <div id="footer-logo"><a href="https://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
